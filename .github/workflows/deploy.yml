name: Deploy to VPS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      deployment_branch:
        description: 'Branch or tag to deploy'
        required: true
        default: 'main'
        type: string
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - backend-only
          - frontend-only
      force_deploy:
        description: 'Force deployment (skip some safety checks)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  issues: write

env:
  DEPLOY_LOG_FILE: deployment-$(date +%Y%m%d-%H%M%S).log

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_branch }}
          fetch-depth: 0

      - name: Set up deployment environment
        run: |
          echo "DEPLOYMENT_TIMESTAMP=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          echo "DEPLOYMENT_ID=${{ github.run_id }}-${{ github.run_attempt }}" >> $GITHUB_ENV
          echo "BACKUP_TAG=pre-deploy-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          
          # Set up deployment paths based on environment
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "DEPLOY_HOST=${{ secrets.PROD_DEPLOY_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.PROD_DEPLOY_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.PROD_DEPLOY_PATH }}" >> $GITHUB_ENV
          else
            echo "DEPLOY_HOST=${{ secrets.STAGING_DEPLOY_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.STAGING_DEPLOY_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.STAGING_DEPLOY_PATH }}" >> $GITHUB_ENV
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          # Frontend dependencies
          cd frontend
          npm ci --only=production
          cd ..
          
          # Backend dependencies
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build frontend
        if: ${{ github.event.inputs.deployment_type != 'backend-only' }}
        run: |
          cd frontend
          npm run build
          
          # Verify build output
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "‚ùå Frontend build failed - dist directory is empty"
            exit 1
          fi
          echo "‚úÖ Frontend build completed successfully"

      - name: Prepare backend deployment package
        if: ${{ github.event.inputs.deployment_type != 'frontend-only' }}
        run: |
          # Create deployment package directory
          mkdir -p deployment-package/backend
          
          # Copy backend files (excluding development files)
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='tests/' \
                --exclude='*.log' --exclude='.env' --exclude='venv/' \
                backend/ deployment-package/backend/
          
          # Copy requirements
          cp requirements.txt deployment-package/
          
          echo "‚úÖ Backend deployment package prepared"

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          
          # Add known hosts to avoid host key verification issues
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connection
          ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no \
              $DEPLOY_USER@$DEPLOY_HOST "echo 'SSH connection successful'" || {
            echo "‚ùå SSH connection failed"
            exit 1
          }
          echo "‚úÖ SSH connection verified"

      - name: Create pre-deployment backup
        run: |
          echo "Creating backup before deployment..."
          
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Create backup using existing backup script
            if [ -f '$DEPLOY_PATH/current/scripts/backup.sh' ]; then
              cd '$DEPLOY_PATH/current'
              sudo -u $DEPLOY_USER BACKUP_DIR='$DEPLOY_PATH/backups' ./scripts/backup.sh daily
            else
              # Fallback manual backup if script doesn't exist
              mkdir -p '$DEPLOY_PATH/backups'
              if [ -d '$DEPLOY_PATH/current' ]; then
                sudo tar -czf '$DEPLOY_PATH/backups/backup-$BACKUP_TAG.tar.gz' \
                  -C '$DEPLOY_PATH' current/ 2>/dev/null || true
              fi
            fi
            
            # Verify backup was created
            if [ -f '$DEPLOY_PATH/backups/'*'$BACKUP_TAG'* ] || [ -f '$DEPLOY_PATH/backups/daily_backup_'* ]; then
              echo '‚úÖ Backup created successfully'
              ls -la '$DEPLOY_PATH/backups/' | tail -3
            else
              echo '‚ùå Backup creation failed'
              exit 1
            fi
          "

      - name: Deploy application
        id: deploy
        run: |
          echo "Starting deployment to $DEPLOY_HOST..."
          
          # Create new release directory
          RELEASE_DIR="$DEPLOY_PATH/releases/release-$DEPLOYMENT_TIMESTAMP"
          
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Create releases directory structure
            mkdir -p '$DEPLOY_PATH/releases'
            mkdir -p '$RELEASE_DIR'
            
            echo 'Release directory created: $RELEASE_DIR'
          "
          
          # Deploy based on deployment type
          case "${{ github.event.inputs.deployment_type }}" in
            "full")
              echo "Performing full deployment..."
              
              # Deploy backend
              if [ -d "deployment-package/backend" ]; then
                rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" \
                  deployment-package/backend/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/backend/
              fi
              
              # Deploy frontend
              if [ -d "frontend/dist" ]; then
                rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" \
                  frontend/dist/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/frontend/dist/
              fi
              
              # Copy other necessary files
              scp -i ~/.ssh/deploy_key requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
              rsync -avz -e "ssh -i ~/.ssh/deploy_key" scripts/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/scripts/
              ;;
              
            "backend-only")
              echo "Performing backend-only deployment..."
              rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" \
                deployment-package/backend/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/backend/
              scp -i ~/.ssh/deploy_key requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
              ;;
              
            "frontend-only")
              echo "Performing frontend-only deployment..."
              rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" \
                frontend/dist/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/frontend/dist/
              ;;
          esac
          
          echo "RELEASE_DIR=$RELEASE_DIR" >> $GITHUB_OUTPUT

      - name: Install dependencies and prepare release
        if: ${{ github.event.inputs.deployment_type != 'frontend-only' }}
        run: |
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            cd '${{ steps.deploy.outputs.RELEASE_DIR }}'
            
            # Create Python virtual environment
            if [ ! -d 'backend/venv' ]; then
              cd backend
              python3 -m venv venv
              source venv/bin/activate
              pip install --upgrade pip
              pip install -r ../requirements.txt
              cd ..
            fi
            
            # Copy environment file from current deployment if it exists
            if [ -f '$DEPLOY_PATH/current/backend/.env' ]; then
              cp '$DEPLOY_PATH/current/backend/.env' backend/
            fi
            
            echo '‚úÖ Dependencies installed and release prepared'
          "

      - name: Atomic deployment switch
        id: atomic_switch
        run: |
          echo "Performing atomic deployment switch..."
          
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Stop services before switching
            sudo systemctl stop productivity-hub 2>/dev/null || true
            
            # Backup current symlink
            if [ -L '$DEPLOY_PATH/current' ]; then
              PREVIOUS_RELEASE=\$(readlink '$DEPLOY_PATH/current')
              echo 'PREVIOUS_RELEASE='\$PREVIOUS_RELEASE >> /tmp/deployment_info
            fi
            
            # Atomic switch to new release
            ln -sfn '${{ steps.deploy.outputs.RELEASE_DIR }}' '$DEPLOY_PATH/current-tmp'
            mv '$DEPLOY_PATH/current-tmp' '$DEPLOY_PATH/current'
            
            echo '‚úÖ Atomic switch completed'
            echo 'NEW_RELEASE=${{ steps.deploy.outputs.RELEASE_DIR }}' >> /tmp/deployment_info
          "

      - name: Start services and health check
        id: health_check
        run: |
          echo "Starting services and performing health check..."
          
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Start services
            sudo systemctl start productivity-hub
            sudo systemctl reload nginx 2>/dev/null || sudo systemctl restart nginx
            
            # Wait for services to start
            sleep 10
            
            # Health check
            for i in {1..6}; do
              if curl -f http://localhost:5000/ >/dev/null 2>&1; then
                echo '‚úÖ Health check passed'
                echo 'HEALTH_CHECK=success' >> /tmp/deployment_info
                exit 0
              fi
              echo \"Health check attempt \$i failed, waiting...\"
              sleep 10
            done
            
            echo '‚ùå Health check failed after multiple attempts'
            echo 'HEALTH_CHECK=failed' >> /tmp/deployment_info
            exit 1
          "

      - name: Deployment rollback
        if: failure() && steps.atomic_switch.conclusion == 'success'
        run: |
          echo "üîÑ Deployment failed, initiating rollback..."
          
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Get deployment info
            source /tmp/deployment_info 2>/dev/null || true
            
            # Stop failed services
            sudo systemctl stop productivity-hub 2>/dev/null || true
            
            if [ -n \"\$PREVIOUS_RELEASE\" ] && [ -d \"\$PREVIOUS_RELEASE\" ]; then
              echo 'Rolling back to: '\$PREVIOUS_RELEASE
              ln -sfn \"\$PREVIOUS_RELEASE\" '$DEPLOY_PATH/current'
              
              # Restart services with previous release
              sudo systemctl start productivity-hub
              sudo systemctl reload nginx 2>/dev/null || sudo systemctl restart nginx
              
              # Verify rollback
              sleep 10
              if curl -f http://localhost:5000/ >/dev/null 2>&1; then
                echo '‚úÖ Rollback successful'
              else
                echo '‚ùå Rollback verification failed'
              fi
            else
              echo '‚ö†Ô∏è No previous release found for rollback'
            fi
            
            # Clean up failed release
            if [ -n \"\$NEW_RELEASE\" ] && [ -d \"\$NEW_RELEASE\" ]; then
              rm -rf \"\$NEW_RELEASE\"
              echo 'Failed release cleaned up'
            fi
          "

      - name: Cleanup old releases
        if: success()
        run: |
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST "
            # Keep only the last 5 releases
            cd '$DEPLOY_PATH/releases'
            ls -t | tail -n +6 | xargs -r rm -rf
            echo '‚úÖ Old releases cleaned up'
          "

      - name: Create deployment success issue comment
        if: success()
        run: |
          echo "üöÄ **Deployment Successful**

          **Deployment Details:**
          - Environment: ${{ github.event.inputs.environment }}
          - Branch/Tag: ${{ github.event.inputs.deployment_branch }}
          - Type: ${{ github.event.inputs.deployment_type }}
          - Deployment ID: ${{ env.DEPLOYMENT_ID }}
          - Release Directory: ${{ steps.deploy.outputs.RELEASE_DIR }}

          **Verification:**
          - ‚úÖ Build completed successfully
          - ‚úÖ Backup created before deployment
          - ‚úÖ Atomic deployment switch completed
          - ‚úÖ Health checks passed
          - ‚úÖ Services running normally

          **Deployed Commit:** ${{ github.sha }}
          **Deployment Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          " > deployment_success.md

      - name: Create failure notification issue
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get the deployment logs and error information
            const failedStep = '${{ job.status }}' === 'failure' ? 'deployment' : 'unknown';
            const deploymentBranch = '${{ github.event.inputs.deployment_branch }}';
            const deploymentType = '${{ github.event.inputs.deployment_type }}';
            const environment = '${{ github.event.inputs.environment }}';
            
            const issueBody = `## üö® Deployment Failure Alert

            **Deployment failed and automatic rollback has been initiated.**

            ### Deployment Details
            - **Environment:** ${environment}
            - **Branch/Tag:** ${deploymentBranch}
            - **Deployment Type:** ${deploymentType}
            - **Deployment ID:** ${{ env.DEPLOYMENT_ID }}
            - **Failed Step:** ${failedStep}
            - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

            ### Failure Information
            - **Commit:** ${{ github.sha }}
            - **Triggered By:** @${{ github.actor }}
            - **Failure Time:** ${new Date().toISOString()}

            ### Actions Taken
            - ‚úÖ Pre-deployment backup was created
            - üîÑ Automatic rollback initiated
            - ‚ö†Ô∏è Please check workflow logs for detailed error information

            ### Next Steps
            1. Review the workflow logs above to identify the failure cause
            2. Fix the identified issues
            3. Test the fixes locally or in staging
            4. Retry the deployment when ready

            ### Backup Information
            A backup was created before deployment with tag: ${{ env.BACKUP_TAG }}
            Location: \`$DEPLOY_PATH/backups/\`

            ---
            This issue was automatically created by the deployment workflow.
            `;

            try {
              const response = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üö® Deployment Failure - ${environment} (${deploymentBranch})`,
                body: issueBody,
                labels: ['deployment', 'urgent', 'auto-generated']
              });
              
              console.log(`Created failure notification issue: ${response.data.html_url}`);
            } catch (error) {
              console.error('Failed to create issue:', error);
            }

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "SSH cleanup completed"