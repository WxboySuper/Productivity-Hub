name: Deploy to VPS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      deployment_branch:
        description: 'Branch or tag to deploy'
        required: true
        default: 'main'
        type: string
      deployment_type:
        description: 'Type of deployment'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - backend-only
          - frontend-only
      force_deploy:
        description: 'Force deployment (skip some safety checks)'
        required: false
        default: false
        type: boolean
      incremental_deploy:
        description: 'Use incremental deployment (only changed files)'
        required: false
        default: true
        type: boolean
      first_deployment:
        description: 'First deployment (full server setup)'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  issues: write

env:
  DEPLOY_LOG_FILE: deployment-$(date +%Y%m%d-%H%M%S).log

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_branch }}
          fetch-depth: 0

      - name: Set up deployment environment
        run: |
          echo "DEPLOYMENT_TIMESTAMP=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          echo "DEPLOYMENT_ID=${{ github.run_id }}-${{ github.run_attempt }}" >> $GITHUB_ENV
          echo "BACKUP_TAG=pre-deploy-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_ENV
          
          # Set up deployment paths based on environment
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            echo "DEPLOY_HOST=${{ secrets.PROD_DEPLOY_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.PROD_DEPLOY_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.PROD_DEPLOY_PATH }}" >> $GITHUB_ENV
            echo "SSH_PASSWORD=${{ secrets.PROD_SSH_PASSWORD }}" >> $GITHUB_ENV
          else
            echo "DEPLOY_HOST=${{ secrets.STAGING_DEPLOY_HOST }}" >> $GITHUB_ENV
            echo "DEPLOY_USER=${{ secrets.STAGING_DEPLOY_USER }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=${{ secrets.STAGING_DEPLOY_PATH }}" >> $GITHUB_ENV
            echo "SSH_PASSWORD=${{ secrets.STAGING_SSH_PASSWORD }}" >> $GITHUB_ENV
          fi
          
          # Set up authentication method
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
            echo "AUTH_METHOD=key" >> $GITHUB_ENV
          elif [ -n "${SSH_PASSWORD}" ]; then
            echo "AUTH_METHOD=password" >> $GITHUB_ENV
          else
            echo "‚ùå No authentication method configured"
            exit 1
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          # Frontend dependencies
          cd frontend
          npm ci --only=production
          cd ..
          
          # Backend dependencies
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build frontend
        if: ${{ github.event.inputs.deployment_type != 'backend-only' }}
        run: |
          cd frontend
          npm run build
          
          # Verify build output
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "‚ùå Frontend build failed - dist directory is empty"
            exit 1
          fi
          echo "‚úÖ Frontend build completed successfully"

      - name: Prepare backend deployment package
        if: ${{ github.event.inputs.deployment_type != 'frontend-only' }}
        run: |
          # Create deployment package directory
          mkdir -p deployment-package/backend
          
          # Copy backend files (excluding development files)
          rsync -av --exclude='*.pyc' --exclude='__pycache__' --exclude='tests/' \
                --exclude='*.log' --exclude='.env' --exclude='venv/' \
                backend/ deployment-package/backend/
          
          # Copy requirements
          cp requirements.txt deployment-package/
          
          echo "‚úÖ Backend deployment package prepared"

      - name: Set up SSH and authentication
        run: |
          if [ "$AUTH_METHOD" = "key" ]; then
            echo "Setting up SSH key authentication..."
            mkdir -p ~/.ssh
            echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
            chmod 600 ~/.ssh/deploy_key
            
            # Add known hosts to avoid host key verification issues
            ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
            
            # Test SSH connection
            ssh -i ~/.ssh/deploy_key -o ConnectTimeout=10 -o StrictHostKeyChecking=no \
                $DEPLOY_USER@$DEPLOY_HOST "echo 'SSH key connection successful'" || {
              echo "‚ùå SSH key connection failed"
              exit 1
            }
            echo "‚úÖ SSH key connection verified"
            
            # Set SSH command for use in other steps
            echo 'SSH_CMD=ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no' >> $GITHUB_ENV
            echo 'RSYNC_SSH=ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no' >> $GITHUB_ENV
          
          elif [ "$AUTH_METHOD" = "password" ]; then
            echo "Setting up SSH password authentication..."
            
            # Install sshpass for password authentication
            sudo apt-get update
            sudo apt-get install -y sshpass
            
            # Add known hosts to avoid host key verification issues
            ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
            
            # Test SSH connection with password
            sshpass -p "$SSH_PASSWORD" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no \
                $DEPLOY_USER@$DEPLOY_HOST "echo 'SSH password connection successful'" || {
              echo "‚ùå SSH password connection failed"
              exit 1
            }
            echo "‚úÖ SSH password connection verified"
            
            # Set SSH command for use in other steps
            echo "SSH_CMD=sshpass -p \"$SSH_PASSWORD\" ssh -o StrictHostKeyChecking=no" >> $GITHUB_ENV
            echo "RSYNC_SSH=sshpass -p \"$SSH_PASSWORD\" ssh -o StrictHostKeyChecking=no" >> $GITHUB_ENV
          
          else
            echo "‚ùå Unknown authentication method: $AUTH_METHOD"
            exit 1
          fi

      - name: First deployment setup
        if: ${{ github.event.inputs.first_deployment == 'true' }}
        run: |
          echo "üöÄ Performing first deployment setup..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Update system packages
            sudo apt update && sudo apt upgrade -y
            
            # Install required packages
            sudo apt install -y python3 python3-pip python3-venv nodejs npm nginx git sqlite3 curl systemctl
            
            # Create deployment directories
            sudo mkdir -p '$DEPLOY_PATH'
            sudo mkdir -p '$DEPLOY_PATH/releases'
            sudo mkdir -p '$DEPLOY_PATH/backups'
            sudo mkdir -p /var/log/productivity-hub
            sudo mkdir -p /etc/systemd/system
            
            # Set up directory permissions
            sudo chown -R $DEPLOY_USER:$DEPLOY_USER '$DEPLOY_PATH'
            sudo chown -R $DEPLOY_USER:$DEPLOY_USER /var/log/productivity-hub
            
            # Install latest Node.js (if version is old)
            NODE_VERSION=\$(node --version 2>/dev/null | cut -d'v' -f2 | cut -d'.' -f1)
            if [ -z \"\$NODE_VERSION\" ] || [ \"\$NODE_VERSION\" -lt 18 ]; then
              echo 'Installing Node.js 18...'
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt-get install -y nodejs
            fi
            
            echo '‚úÖ First deployment setup completed'
          "
          
          echo "‚úÖ Server prepared for first deployment"

      - name: Create pre-deployment backup
        if: ${{ github.event.inputs.first_deployment != 'true' }}
        run: |
          echo "Creating backup before deployment..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Create backup using existing backup script
            if [ -f '$DEPLOY_PATH/current/scripts/backup.sh' ]; then
              cd '$DEPLOY_PATH/current'
              sudo -u $DEPLOY_USER BACKUP_DIR='$DEPLOY_PATH/backups' ./scripts/backup.sh daily
            else
              # Fallback manual backup if script doesn't exist
              mkdir -p '$DEPLOY_PATH/backups'
              if [ -d '$DEPLOY_PATH/current' ]; then
                sudo tar -czf '$DEPLOY_PATH/backups/backup-$BACKUP_TAG.tar.gz' \
                  -C '$DEPLOY_PATH' current/ 2>/dev/null || true
              fi
            fi
            
            # Verify backup was created
            if [ -f '$DEPLOY_PATH/backups/'*'$BACKUP_TAG'* ] || [ -f '$DEPLOY_PATH/backups/daily_backup_'* ]; then
              echo '‚úÖ Backup created successfully'
              ls -la '$DEPLOY_PATH/backups/' | tail -3
            else
              echo '‚ùå Backup creation failed'
              exit 1
            fi
          "

      - name: Deploy application
        id: deploy
        run: |
          echo "Starting deployment to $DEPLOY_HOST..."
          
          # Create new release directory
          RELEASE_DIR="$DEPLOY_PATH/releases/release-$DEPLOYMENT_TIMESTAMP"
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Create releases directory structure
            mkdir -p '$DEPLOY_PATH/releases'
            mkdir -p '$RELEASE_DIR'
            
            echo 'Release directory created: $RELEASE_DIR'
          "
          
          # Set up rsync options for incremental deployment
          RSYNC_OPTS="-avz --delete"
          if [ "${{ github.event.inputs.incremental_deploy }}" = "true" ] && [ "${{ github.event.inputs.first_deployment }}" != "true" ]; then
            echo "üîÑ Using incremental deployment (only changed files)"
            RSYNC_OPTS="$RSYNC_OPTS --checksum --update"
          else
            echo "üì¶ Using full deployment (all files)"
          fi
          
          # Deploy based on deployment type
          case "${{ github.event.inputs.deployment_type }}" in
            "full")
              echo "Performing full deployment..."
              
              # Deploy backend
              if [ -d "deployment-package/backend" ]; then
                rsync $RSYNC_OPTS -e "$RSYNC_SSH" \
                  deployment-package/backend/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/backend/
              fi
              
              # Deploy frontend
              if [ -d "frontend/dist" ]; then
                rsync $RSYNC_OPTS -e "$RSYNC_SSH" \
                  frontend/dist/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/frontend/dist/
              fi
              
              # Copy other necessary files
              if [ "$AUTH_METHOD" = "key" ]; then
                scp -i ~/.ssh/deploy_key requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
                rsync -avz -e "ssh -i ~/.ssh/deploy_key" scripts/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/scripts/
                rsync -avz -e "ssh -i ~/.ssh/deploy_key" config/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/config/
              else
                sshpass -p "$SSH_PASSWORD" scp requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
                rsync -avz -e "sshpass -p \"$SSH_PASSWORD\" ssh" scripts/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/scripts/
                rsync -avz -e "sshpass -p \"$SSH_PASSWORD\" ssh" config/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/config/
              fi
              ;;
              
            "backend-only")
              echo "Performing backend-only deployment..."
              rsync $RSYNC_OPTS -e "$RSYNC_SSH" \
                deployment-package/backend/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/backend/
              if [ "$AUTH_METHOD" = "key" ]; then
                scp -i ~/.ssh/deploy_key requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
              else
                sshpass -p "$SSH_PASSWORD" scp requirements.txt $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/
              fi
              ;;
              
            "frontend-only")
              echo "Performing frontend-only deployment..."
              rsync $RSYNC_OPTS -e "$RSYNC_SSH" \
                frontend/dist/ $DEPLOY_USER@$DEPLOY_HOST:$RELEASE_DIR/frontend/dist/
              ;;
          esac
          
          echo "RELEASE_DIR=$RELEASE_DIR" >> $GITHUB_OUTPUT

      - name: Setup services for first deployment
        if: ${{ github.event.inputs.first_deployment == 'true' }}
        run: |
          echo "Setting up services for first deployment..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            cd '${{ steps.deploy.outputs.RELEASE_DIR }}'
            
            # Install systemd service
            if [ -f 'config/systemd/productivity-hub.service' ]; then
              sudo cp config/systemd/productivity-hub.service /etc/systemd/system/
              # Update paths in service file for actual deployment path
              sudo sed -i \"s|/var/www/productivity-hub|\$DEPLOY_PATH|g\" /etc/systemd/system/productivity-hub.service
              sudo sed -i \"s|User=productivity|User=\$DEPLOY_USER|g\" /etc/systemd/system/productivity-hub.service
              sudo systemctl daemon-reload
              sudo systemctl enable productivity-hub
            fi
            
            # Setup nginx configuration
            if [ -f 'config/nginx/productivity-hub.conf' ]; then
              sudo cp config/nginx/productivity-hub.conf /etc/nginx/sites-available/
              # Update domain name for productivity.weatherboysuper.com
              sudo sed -i 's/your-domain.com/productivity.weatherboysuper.com/g' /etc/nginx/sites-available/productivity-hub.conf
              sudo sed -i \"s|/var/www/productivity-hub|\$DEPLOY_PATH|g\" /etc/nginx/sites-available/productivity-hub.conf
              sudo ln -sf /etc/nginx/sites-available/productivity-hub.conf /etc/nginx/sites-enabled/
              sudo nginx -t
            fi
            
            echo '‚úÖ Services configured for first deployment'
          "

      - name: Atomic deployment switch
        id: atomic_switch
        run: |
          echo "Performing atomic deployment switch..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Stop services before switching
            sudo systemctl stop productivity-hub 2>/dev/null || true
            
            # Backup current symlink
            if [ -L '$DEPLOY_PATH/current' ]; then
              PREVIOUS_RELEASE=\$(readlink '$DEPLOY_PATH/current')
              echo 'PREVIOUS_RELEASE='\$PREVIOUS_RELEASE >> /tmp/deployment_info
            fi
            
            # Atomic switch to new release
            ln -sfn '${{ steps.deploy.outputs.RELEASE_DIR }}' '$DEPLOY_PATH/current-tmp'
            mv '$DEPLOY_PATH/current-tmp' '$DEPLOY_PATH/current'
            
            echo '‚úÖ Atomic switch completed'
            echo 'NEW_RELEASE=${{ steps.deploy.outputs.RELEASE_DIR }}' >> /tmp/deployment_info
          "

      - name: Start services and health check
        id: health_check
        run: |
          echo "Starting services and performing health check..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Start services
            sudo systemctl start productivity-hub
            sudo systemctl reload nginx 2>/dev/null || sudo systemctl restart nginx
            
            # Wait for services to start
            sleep 10
            
            # Health check - try both localhost and the actual domain
            for i in {1..6}; do
              if curl -f http://localhost:5000/ >/dev/null 2>&1; then
                echo '‚úÖ Health check passed (localhost)'
                echo 'HEALTH_CHECK=success' >> /tmp/deployment_info
                exit 0
              elif curl -f http://productivity.weatherboysuper.com/ >/dev/null 2>&1; then
                echo '‚úÖ Health check passed (domain)'
                echo 'HEALTH_CHECK=success' >> /tmp/deployment_info
                exit 0
              fi
              echo \"Health check attempt \$i failed, waiting...\"
              sleep 10
            done
            
            echo '‚ùå Health check failed after multiple attempts'
            echo 'HEALTH_CHECK=failed' >> /tmp/deployment_info
            exit 1
          "

      - name: Deployment rollback
        if: failure() && steps.atomic_switch.conclusion == 'success'
        run: |
          echo "üîÑ Deployment failed, initiating rollback..."
          
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Get deployment info
            source /tmp/deployment_info 2>/dev/null || true
            
            # Stop failed services
            sudo systemctl stop productivity-hub 2>/dev/null || true
            
            if [ -n \"\$PREVIOUS_RELEASE\" ] && [ -d \"\$PREVIOUS_RELEASE\" ]; then
              echo 'Rolling back to: '\$PREVIOUS_RELEASE
              ln -sfn \"\$PREVIOUS_RELEASE\" '$DEPLOY_PATH/current'
              
              # Restart services with previous release
              sudo systemctl start productivity-hub
              sudo systemctl reload nginx 2>/dev/null || sudo systemctl restart nginx
              
              # Verify rollback
              sleep 10
              if curl -f http://localhost:5000/ >/dev/null 2>&1; then
                echo '‚úÖ Rollback successful'
              else
                echo '‚ùå Rollback verification failed'
              fi
            else
              echo '‚ö†Ô∏è No previous release found for rollback'
            fi
            
            # Clean up failed release
            if [ -n \"\$NEW_RELEASE\" ] && [ -d \"\$NEW_RELEASE\" ]; then
              rm -rf \"\$NEW_RELEASE\"
              echo 'Failed release cleaned up'
            fi
          "

      - name: Cleanup old releases
        if: success()
        run: |
          $SSH_CMD $DEPLOY_USER@$DEPLOY_HOST "
            # Keep only the last 5 releases
            cd '$DEPLOY_PATH/releases'
            ls -t | tail -n +6 | xargs -r rm -rf
            echo '‚úÖ Old releases cleaned up'
          "

      - name: Create deployment success issue comment
        if: success()
        run: |
          echo "üöÄ **Deployment Successful**

          **Deployment Details:**
          - Environment: ${{ github.event.inputs.environment }}
          - Branch/Tag: ${{ github.event.inputs.deployment_branch }}
          - Type: ${{ github.event.inputs.deployment_type }}
          - Deployment Mode: ${{ github.event.inputs.incremental_deploy == 'true' && 'Incremental' || 'Full' }}
          - First Deployment: ${{ github.event.inputs.first_deployment }}
          - Authentication: ${{ env.AUTH_METHOD }}
          - Deployment ID: ${{ env.DEPLOYMENT_ID }}
          - Release Directory: ${{ steps.deploy.outputs.RELEASE_DIR }}

          **Verification:**
          - ‚úÖ Build completed successfully
          - ‚úÖ ${{ github.event.inputs.first_deployment == 'true' && 'Server setup completed' || 'Backup created before deployment' }}
          - ‚úÖ Atomic deployment switch completed
          - ‚úÖ Health checks passed
          - ‚úÖ Services running normally
          - ‚úÖ Available at: https://productivity.weatherboysuper.com

          **Deployed Commit:** ${{ github.sha }}
          **Deployment Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          " > deployment_success.md

      - name: Create failure notification issue
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get the deployment logs and error information
            const failedStep = '${{ job.status }}' === 'failure' ? 'deployment' : 'unknown';
            const deploymentBranch = '${{ github.event.inputs.deployment_branch }}';
            const deploymentType = '${{ github.event.inputs.deployment_type }}';
            const environment = '${{ github.event.inputs.environment }}';
            
            const issueBody = `## üö® Deployment Failure Alert

            **Deployment failed and automatic rollback has been initiated.**

            ### Deployment Details
            - **Environment:** ${environment}
            - **Branch/Tag:** ${deploymentBranch}
            - **Deployment Type:** ${deploymentType}
            - **Deployment ID:** ${{ env.DEPLOYMENT_ID }}
            - **Failed Step:** ${failedStep}
            - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

            ### Failure Information
            - **Commit:** ${{ github.sha }}
            - **Triggered By:** @${{ github.actor }}
            - **Failure Time:** ${new Date().toISOString()}

            ### Actions Taken
            - ‚úÖ Pre-deployment backup was created
            - üîÑ Automatic rollback initiated
            - ‚ö†Ô∏è Please check workflow logs for detailed error information

            ### Next Steps
            1. Review the workflow logs above to identify the failure cause
            2. Fix the identified issues
            3. Test the fixes locally or in staging
            4. Retry the deployment when ready

            ### Backup Information
            A backup was created before deployment with tag: ${{ env.BACKUP_TAG }}
            Location: \`$DEPLOY_PATH/backups/\`

            ---
            This issue was automatically created by the deployment workflow.
            `;

            try {
              const response = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üö® Deployment Failure - ${environment} (${deploymentBranch})`,
                body: issueBody,
                labels: ['deployment', 'urgent', 'auto-generated']
              });
              
              console.log(`Created failure notification issue: ${response.data.html_url}`);
            } catch (error) {
              console.error('Failed to create issue:', error);
            }

      - name: Cleanup SSH
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          echo "SSH cleanup completed"